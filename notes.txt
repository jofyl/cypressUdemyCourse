Link with many examples
=======================
https://github.com/cypress-io/cypress-example-recipes

Introduction
============

You can force click on elements een if they are hidden behind other popup elements behind.

Handle API validation and check request data being sent.

You can also mock API responses to test edge cases such as the backend being down (4xx, 5xx) which normally can not be tested in real time since they would be flagged as "not right for automation".

npmtrends.com => check usage of Node tools and packages

electron also supported => lighweight version of chromium engine

brew install node

npmjs.com

use npm to manage project dependencies with Package.json

create a project folder
init Package.json => npm -i init

install cypress: npm install cypress --save-dev

to open cypress test runner
./node_modules/.bin/cypress open

clicking on any test in testrunner open runs is

cy => global object to invoke all cypress commands
visit() method => used to navigate to page

cypress bundles electron browser
when running test from the command line, cypress runs in headless mode

when running tests using npm
npm run commandname -- listOfArguments => the "--" are used to pass the arguments through npm

when running tests using cypress directly
cypress run listOfArguments

listOfArguments => when running 1 test (or spec file), use a local pass, starting from the "cypress" folder inside your project

cypress by default, runs in headless mode in electron folder

you can use "/*" to tell cypress to run all the test in a directory

to run in headed mode (i.e browser will open on screen) => --headed
to run in a browser, --browser name => --browser firefox
npm run cy:run -- --spec 'cypress/integration/example/*' --headed --browser firefox

Framework Structure
===================
fixture => used to store data that can be loaded when testing
integration => used to store test suites and test cases
plugins => configs for cypress event listeners, for example, on browser invoke do this, or when test fails, do that
support => write your customized commands or reusable commands, methods... etc, this folder is scanned and imported by default by cypress. in case you define another folder, you will need to import it in you spec files to use it

cypress.json => configuration files for cypress, can be used to override default existing configurations
(durations are in milliseconds)


Cypress supports only CSS selectors
===================================
identified by:
id: #idname
classname: .classname
if there are multiple elements with the same classname, you can use tagname: tagname.classname, can also be used with id: tagname#idname
or as tagname[attribute=value] => the latter can be used to customize with any attribute./no

for example:
<input type="search" placeholder="Search for Vegetables and Fruits" class="search-keyword">
- no id here
- classname: .search-keyword
- input.search-keyword //with tagename
- input[type="search"] //with tagename

=> cypress built-in browser allows you to find elements on the page

Note: ".btn.btn-info" is the same as ".btn btn-info" => replace the space with a dot when dealing with classes

Waits
=====
If there is a waiting icon or some kind of clue for cypress to understant that the page is loading, or data is loading, it catches it and it waits, else we will have to provided it with a wait timer

Debug
=====
Easy to debug, can see every step along with screenshots of the page

Practice Pages
==============
https://rahulshettyacademy.com/seleniumPractise/#/
https://www.rahulshettyacademy.com/AutomationPractice/

parent child chaining
=====================
get().find() => search only within the selected elements
get().get() => get is chained to "cy", so even if get() are chained, each will still through the enire document

So the command cy.get("a").find("b") returns all the b elements which are successor of an a element, but cy.get("a").get("b") finds all the a and b elements regardless of they are parent and child.

Using CSS, this can be done by adding a whitespace

Execution
=========
cypress is asynchronous in nature, so there is no guarantee that the steps will execute in sequence, but cypress takes care of it, it has the necessary logic implemented as part od its engine to do this

Promises
========
States: rejection, resolved, pending => the "then()" method is hidden (less noise), taken care of by cypress
thus, cypress commands are really promises

Cypress Commands vs JQuery Methods - .text()
============================================
cy.get('.brand').text(): this will not work, text() is not cypress method or command
this comes from JQuery: https://docs.cypress.io/api/table-of-contents
When dealing with methods that are not part of cypress, then the you will have to resolve
the promise manually using .then() since the commands do not resolve the promises by themselves

Another example would be console.log(), since it is JS and not cypress method, if will execute asynchronously, so in order to use it woth cypress
.the(() => {
    console.log('bla');
})

Chrome Security
===============
https://docs.cypress.io/guides/guides/web-security#Disabling-Web-Security
Check the following link in case you encouter cross-origin/cross-domain errors or when dealing with iframes

User appropriate methods - checkboxes and dropdowns
===================================================
check() and uncheck() for checkboxes for example
should('be.checked') when asserting

assertions can be chained
should('be.checked').and('have.value', 'option1')

Assertions: Behavior vs Property
================================
have => property
be => behavior

Popups
======
cypress handles popups automatically, it auto accetps or clicks "OK", but there is a way to test it
but cypress also listens to browser events

Child tabs (method 1)
=====================
Unlike other tools and rivers, cypress do not handled child tabs, tabs that are opened by the current test tab in the same browser.
This helps avoid flaky tests.

but, there is actuyally a work around:
1st check the following: https://www.w3schools.com/tags/att_a_target.asp
in short, it is related to the attribute: target="_blank"
=> manipulate the DOM (cypress can do that) and delete it set it to "_self"

We will use invoke() to invoke a JQuery function to modify the DOM

Can user 'include' => with chai to assert on substring

Tables - selecting a column - nth-child(x)
==========================================
tr td:nth-child(2)
finding the next or previous sybling element
.next() or .prev()
carefull, if you are iterating using each(), the retreived elements are JQuery elements, so .next() and .pre() can not be applied on it

Mouse Hover
===========
Cypress itself does not support mouse hover, it is flaky and the mouse can hover then disapear, instead use JQuery method show() ro find hidden elements
so cypress has the ability to click on hidden elements as well

Child tabs (method 2)
=====================
grab the href attribute then
cy.vist(href value)
=> only works if the origin/domain is the same
=> navigating to sub-domain works

so the best thing to do here, would be to alter the button, remove target="_blank" and alter thr value of its href using JQuery
this should allow the click to navigate to another website
PS: you need to turn off web security from cypress.json
"chromeWebSecurity": false

cy.visit() does not allow cross origin or navigating to "another" super domain, even if security is disabled

Handling Iframes
================
Read https://www.cypress.io/blog/2020/02/12/working-with-iframes-in-cypress/
https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/blogs__iframes
npm install -D cypress-iframe at project level
import 'cypress-iframe' in your spec file
and load it cy.frameLoaded('');

Regular Expression with .find()
===============================
find('h1[class*="pricing-title"]');
The actual full class name is "pricing-title text-white ls-1"

Framework
=========

Hooks
-----
https://docs.cypress.io/guides/core-concepts/writing-and-organizing-tests#Test-Structure
before > beforeEach > afteEach > after
Best to place these hooks inside describe or context for isolation so that they do not run at root level asynchronously and affetct all other test suites

Fixtures
--------
Used to load data into tests
Best load the fixture in the before() method => remember to resolve the promise .then()
use "this." => points to entire class

JS Arrow functions and function declarations
--------------------------------------------
Arrow functions and function declarations / expressions are not equivalent and cannot be replaced blindly.
If the function you want to replace does not use this, arguments and is not called with new, then yes.

Debugging
---------
inspect element -> console
then start checking the cypress executed steps => you can check the logs at each steps in more details

you can also use cy.pause()
or .debug() chained to the commands you want to check

Page Object Model
-----------------
check files in /pageObjects for class creation
check testFramework8.spec.js for usage

JS vs Cypress commands
----------------------
In async mode, JS expressions will execute async, so any time your are using regular JS, you will need to resolve the promise
You will also need to resolve the promise when needing to access the text for variables not being iterated on

Env
---
inside cypress.json

 "env": {
    "url": "https://rahulshettyacademy.com"
  }

and when using it: Cypress.env('url') => call as if a function

and when running this from the terminal:
cypress run --spec ./cypress/integration/example/test9Framework.spec.js --env url=https://google.com --headed